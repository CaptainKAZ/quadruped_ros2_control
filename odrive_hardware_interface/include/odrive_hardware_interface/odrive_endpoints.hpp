/*
* This file was autogenerated using the "odrivetool generate-code" feature.
*
* The file matches a specific firmware version. If you add/remove/rename any
* properties exposed by the ODrive, this file needs to be regenerated, otherwise
* the ODrive will ignore all commands.
*/

#ifndef __ODRIVE_ENDPOINTS_HPP
#define __ODRIVE_ENDPOINTS_HPP


namespace odrive {
    
static constexpr const uint16_t json_crc = 0x9b40;

static constexpr const uint16_t per_axis_offset = 229;

enum { 
    VBUS_VOLTAGE = 1,
    IBUS = 2,
    IBUS_REPORT_FILTER_K = 3,
    SERIAL_NUMBER = 4,
    HW_VERSION_MAJOR = 5,
    HW_VERSION_MINOR = 6,
    HW_VERSION_VARIANT = 7,
    FW_VERSION_MAJOR = 8,
    FW_VERSION_MINOR = 9,
    FW_VERSION_REVISION = 10,
    FW_VERSION_UNRELEASED = 11,
    BRAKE_RESISTOR_ARMED = 12,
    BRAKE_RESISTOR_SATURATED = 13,
    SYSTEM_STATS__UPTIME = 14,
    SYSTEM_STATS__MIN_HEAP_SPACE = 15,
    SYSTEM_STATS__MIN_STACK_SPACE_AXIS0 = 16,
    SYSTEM_STATS__MIN_STACK_SPACE_AXIS1 = 17,
    SYSTEM_STATS__MIN_STACK_SPACE_COMMS = 18,
    SYSTEM_STATS__MIN_STACK_SPACE_USB = 19,
    SYSTEM_STATS__MIN_STACK_SPACE_UART = 20,
    SYSTEM_STATS__MIN_STACK_SPACE_CAN = 21,
    SYSTEM_STATS__MIN_STACK_SPACE_USB_IRQ = 22,
    SYSTEM_STATS__MIN_STACK_SPACE_STARTUP = 23,
    SYSTEM_STATS__STACK_USAGE_AXIS0 = 24,
    SYSTEM_STATS__STACK_USAGE_AXIS1 = 25,
    SYSTEM_STATS__STACK_USAGE_COMMS = 26,
    SYSTEM_STATS__STACK_USAGE_USB = 27,
    SYSTEM_STATS__STACK_USAGE_UART = 28,
    SYSTEM_STATS__STACK_USAGE_USB_IRQ = 29,
    SYSTEM_STATS__STACK_USAGE_STARTUP = 30,
    SYSTEM_STATS__STACK_USAGE_CAN = 31,
    SYSTEM_STATS__USB__RX_CNT = 32,
    SYSTEM_STATS__USB__TX_CNT = 33,
    SYSTEM_STATS__USB__TX_OVERRUN_CNT = 34,
    SYSTEM_STATS__I2C__ADDR = 35,
    SYSTEM_STATS__I2C__ADDR_MATCH_CNT = 36,
    SYSTEM_STATS__I2C__RX_CNT = 37,
    SYSTEM_STATS__I2C__ERROR_CNT = 38,
    CONFIG__ENABLE_UART = 39,
    CONFIG__UART_BAUDRATE = 40,
    CONFIG__ENABLE_I2C_INSTEAD_OF_CAN = 41,
    CONFIG__ENABLE_ASCII_PROTOCOL_ON_USB = 42,
    CONFIG__MAX_REGEN_CURRENT = 43,
    CONFIG__BRAKE_RESISTANCE = 44,
    CONFIG__DC_BUS_UNDERVOLTAGE_TRIP_LEVEL = 45,
    CONFIG__DC_BUS_OVERVOLTAGE_TRIP_LEVEL = 46,
    CONFIG__ENABLE_DC_BUS_OVERVOLTAGE_RAMP = 47,
    CONFIG__DC_BUS_OVERVOLTAGE_RAMP_START = 48,
    CONFIG__DC_BUS_OVERVOLTAGE_RAMP_END = 49,
    CONFIG__DC_MAX_POSITIVE_CURRENT = 50,
    CONFIG__DC_MAX_NEGATIVE_CURRENT = 51,
    CONFIG__GPIO1_PWM_MAPPING__MIN = 53,
    CONFIG__GPIO1_PWM_MAPPING__MAX = 54,
    CONFIG__GPIO2_PWM_MAPPING__MIN = 56,
    CONFIG__GPIO2_PWM_MAPPING__MAX = 57,
    CONFIG__GPIO3_PWM_MAPPING__MIN = 59,
    CONFIG__GPIO3_PWM_MAPPING__MAX = 60,
    CONFIG__GPIO4_PWM_MAPPING__MIN = 62,
    CONFIG__GPIO4_PWM_MAPPING__MAX = 63,
    CONFIG__GPIO3_ANALOG_MAPPING__MIN = 65,
    CONFIG__GPIO3_ANALOG_MAPPING__MAX = 66,
    CONFIG__GPIO4_ANALOG_MAPPING__MIN = 68,
    CONFIG__GPIO4_ANALOG_MAPPING__MAX = 69,
    USER_CONFIG_LOADED = 70,
    CAN__ERROR = 529,
    CAN__CONFIG__BAUD_RATE = 530,
    CAN__CONFIG__PROTOCOL = 531,
    TEST_PROPERTY = 534,
    SAVE_CONFIGURATION = 544,
    ERASE_CONFIGURATION = 545,
    REBOOT = 546,
    ENTER_DFU_MODE = 547,

    // Per-Axis endpoints (to be used with read_axis_property and write_axis_property)
    AXIS__ERROR = 71,
    AXIS__STEP_DIR_ACTIVE = 72,
    AXIS__CURRENT_STATE = 73,
    AXIS__REQUESTED_STATE = 74,
    AXIS__LOOP_COUNTER = 75,
    AXIS__LOCKIN_STATE = 76,
    AXIS__IS_HOMED = 77,
    AXIS__CONFIG__STARTUP_MOTOR_CALIBRATION = 78,
    AXIS__CONFIG__STARTUP_ENCODER_INDEX_SEARCH = 79,
    AXIS__CONFIG__STARTUP_ENCODER_OFFSET_CALIBRATION = 80,
    AXIS__CONFIG__STARTUP_CLOSED_LOOP_CONTROL = 81,
    AXIS__CONFIG__STARTUP_SENSORLESS_CONTROL = 82,
    AXIS__CONFIG__STARTUP_HOMING = 83,
    AXIS__CONFIG__ENABLE_STEP_DIR = 84,
    AXIS__CONFIG__STEP_DIR_ALWAYS_ON = 85,
    AXIS__CONFIG__TURNS_PER_STEP = 86,
    AXIS__CONFIG__WATCHDOG_TIMEOUT = 87,
    AXIS__CONFIG__ENABLE_WATCHDOG = 88,
    AXIS__CONFIG__STEP_GPIO_PIN = 89,
    AXIS__CONFIG__DIR_GPIO_PIN = 90,
    AXIS__CONFIG__CALIBRATION_LOCKIN__CURRENT = 91,
    AXIS__CONFIG__CALIBRATION_LOCKIN__RAMP_TIME = 92,
    AXIS__CONFIG__CALIBRATION_LOCKIN__RAMP_DISTANCE = 93,
    AXIS__CONFIG__CALIBRATION_LOCKIN__ACCEL = 94,
    AXIS__CONFIG__CALIBRATION_LOCKIN__VEL = 95,
    AXIS__CONFIG__SENSORLESS_RAMP__CURRENT = 96,
    AXIS__CONFIG__SENSORLESS_RAMP__RAMP_TIME = 97,
    AXIS__CONFIG__SENSORLESS_RAMP__RAMP_DISTANCE = 98,
    AXIS__CONFIG__SENSORLESS_RAMP__ACCEL = 99,
    AXIS__CONFIG__SENSORLESS_RAMP__VEL = 100,
    AXIS__CONFIG__SENSORLESS_RAMP__FINISH_DISTANCE = 101,
    AXIS__CONFIG__SENSORLESS_RAMP__FINISH_ON_VEL = 102,
    AXIS__CONFIG__SENSORLESS_RAMP__FINISH_ON_DISTANCE = 103,
    AXIS__CONFIG__SENSORLESS_RAMP__FINISH_ON_ENC_IDX = 104,
    AXIS__CONFIG__GENERAL_LOCKIN__CURRENT = 105,
    AXIS__CONFIG__GENERAL_LOCKIN__RAMP_TIME = 106,
    AXIS__CONFIG__GENERAL_LOCKIN__RAMP_DISTANCE = 107,
    AXIS__CONFIG__GENERAL_LOCKIN__ACCEL = 108,
    AXIS__CONFIG__GENERAL_LOCKIN__VEL = 109,
    AXIS__CONFIG__GENERAL_LOCKIN__FINISH_DISTANCE = 110,
    AXIS__CONFIG__GENERAL_LOCKIN__FINISH_ON_VEL = 111,
    AXIS__CONFIG__GENERAL_LOCKIN__FINISH_ON_DISTANCE = 112,
    AXIS__CONFIG__GENERAL_LOCKIN__FINISH_ON_ENC_IDX = 113,
    AXIS__CONFIG__CAN_NODE_ID = 114,
    AXIS__CONFIG__CAN_NODE_ID_EXTENDED = 115,
    AXIS__CONFIG__CAN_HEARTBEAT_RATE_MS = 116,
    AXIS__FET_THERMISTOR__ERROR = 117,
    AXIS__FET_THERMISTOR__TEMPERATURE = 118,
    AXIS__FET_THERMISTOR__CONFIG__TEMP_LIMIT_LOWER = 119,
    AXIS__FET_THERMISTOR__CONFIG__TEMP_LIMIT_UPPER = 120,
    AXIS__FET_THERMISTOR__CONFIG__ENABLED = 121,
    AXIS__MOTOR_THERMISTOR__ERROR = 122,
    AXIS__MOTOR_THERMISTOR__TEMPERATURE = 123,
    AXIS__MOTOR_THERMISTOR__CONFIG__GPIO_PIN = 124,
    AXIS__MOTOR_THERMISTOR__CONFIG__POLY_COEFFICIENT_0 = 125,
    AXIS__MOTOR_THERMISTOR__CONFIG__POLY_COEFFICIENT_1 = 126,
    AXIS__MOTOR_THERMISTOR__CONFIG__POLY_COEFFICIENT_2 = 127,
    AXIS__MOTOR_THERMISTOR__CONFIG__POLY_COEFFICIENT_3 = 128,
    AXIS__MOTOR_THERMISTOR__CONFIG__TEMP_LIMIT_LOWER = 129,
    AXIS__MOTOR_THERMISTOR__CONFIG__TEMP_LIMIT_UPPER = 130,
    AXIS__MOTOR_THERMISTOR__CONFIG__ENABLED = 131,
    AXIS__MOTOR__ERROR = 132,
    AXIS__MOTOR__ARMED_STATE = 133,
    AXIS__MOTOR__IS_CALIBRATED = 134,
    AXIS__MOTOR__CURRENT_MEAS_PHB = 135,
    AXIS__MOTOR__CURRENT_MEAS_PHC = 136,
    AXIS__MOTOR__DC_CALIB_PHB = 137,
    AXIS__MOTOR__DC_CALIB_PHC = 138,
    AXIS__MOTOR__PHASE_CURRENT_REV_GAIN = 139,
    AXIS__MOTOR__EFFECTIVE_CURRENT_LIM = 140,
    AXIS__MOTOR__CURRENT_CONTROL__P_GAIN = 141,
    AXIS__MOTOR__CURRENT_CONTROL__I_GAIN = 142,
    AXIS__MOTOR__CURRENT_CONTROL__V_CURRENT_CONTROL_INTEGRAL_D = 143,
    AXIS__MOTOR__CURRENT_CONTROL__V_CURRENT_CONTROL_INTEGRAL_Q = 144,
    AXIS__MOTOR__CURRENT_CONTROL__IBUS = 145,
    AXIS__MOTOR__CURRENT_CONTROL__FINAL_V_ALPHA = 146,
    AXIS__MOTOR__CURRENT_CONTROL__FINAL_V_BETA = 147,
    AXIS__MOTOR__CURRENT_CONTROL__ID_SETPOINT = 148,
    AXIS__MOTOR__CURRENT_CONTROL__IQ_SETPOINT = 149,
    AXIS__MOTOR__CURRENT_CONTROL__IQ_MEASURED = 150,
    AXIS__MOTOR__CURRENT_CONTROL__ID_MEASURED = 151,
    AXIS__MOTOR__CURRENT_CONTROL__I_MEASURED_REPORT_FILTER_K = 152,
    AXIS__MOTOR__CURRENT_CONTROL__MAX_ALLOWED_CURRENT = 153,
    AXIS__MOTOR__CURRENT_CONTROL__OVERCURRENT_TRIP_LEVEL = 154,
    AXIS__MOTOR__CURRENT_CONTROL__ACIM_ROTOR_FLUX = 155,
    AXIS__MOTOR__CURRENT_CONTROL__ASYNC_PHASE_VEL = 156,
    AXIS__MOTOR__CURRENT_CONTROL__ASYNC_PHASE_OFFSET = 157,
    AXIS__MOTOR__GATE_DRIVER__DRV_FAULT = 158,
    AXIS__MOTOR__TIMING_LOG__GENERAL = 159,
    AXIS__MOTOR__TIMING_LOG__ADC_CB_I = 160,
    AXIS__MOTOR__TIMING_LOG__ADC_CB_DC = 161,
    AXIS__MOTOR__TIMING_LOG__MEAS_R = 162,
    AXIS__MOTOR__TIMING_LOG__MEAS_L = 163,
    AXIS__MOTOR__TIMING_LOG__ENC_CALIB = 164,
    AXIS__MOTOR__TIMING_LOG__IDX_SEARCH = 165,
    AXIS__MOTOR__TIMING_LOG__FOC_VOLTAGE = 166,
    AXIS__MOTOR__TIMING_LOG__FOC_CURRENT = 167,
    AXIS__MOTOR__TIMING_LOG__SPI_START = 168,
    AXIS__MOTOR__TIMING_LOG__SAMPLE_NOW = 169,
    AXIS__MOTOR__TIMING_LOG__SPI_END = 170,
    AXIS__MOTOR__CONFIG__PRE_CALIBRATED = 171,
    AXIS__MOTOR__CONFIG__POLE_PAIRS = 172,
    AXIS__MOTOR__CONFIG__CALIBRATION_CURRENT = 173,
    AXIS__MOTOR__CONFIG__RESISTANCE_CALIB_MAX_VOLTAGE = 174,
    AXIS__MOTOR__CONFIG__PHASE_INDUCTANCE = 175,
    AXIS__MOTOR__CONFIG__PHASE_RESISTANCE = 176,
    AXIS__MOTOR__CONFIG__TORQUE_CONSTANT = 177,
    AXIS__MOTOR__CONFIG__DIRECTION = 178,
    AXIS__MOTOR__CONFIG__MOTOR_TYPE = 179,
    AXIS__MOTOR__CONFIG__CURRENT_LIM = 180,
    AXIS__MOTOR__CONFIG__CURRENT_LIM_MARGIN = 181,
    AXIS__MOTOR__CONFIG__TORQUE_LIM = 182,
    AXIS__MOTOR__CONFIG__INVERTER_TEMP_LIMIT_LOWER = 183,
    AXIS__MOTOR__CONFIG__INVERTER_TEMP_LIMIT_UPPER = 184,
    AXIS__MOTOR__CONFIG__REQUESTED_CURRENT_RANGE = 185,
    AXIS__MOTOR__CONFIG__CURRENT_CONTROL_BANDWIDTH = 186,
    AXIS__MOTOR__CONFIG__ACIM_SLIP_VELOCITY = 187,
    AXIS__MOTOR__CONFIG__ACIM_GAIN_MIN_FLUX = 188,
    AXIS__MOTOR__CONFIG__ACIM_AUTOFLUX_MIN_ID = 189,
    AXIS__MOTOR__CONFIG__ACIM_AUTOFLUX_ENABLE = 190,
    AXIS__MOTOR__CONFIG__ACIM_AUTOFLUX_ATTACK_GAIN = 191,
    AXIS__MOTOR__CONFIG__ACIM_AUTOFLUX_DECAY_GAIN = 192,
    AXIS__CONTROLLER__ERROR = 193,
    AXIS__CONTROLLER__INPUT_POS = 194,
    AXIS__CONTROLLER__INPUT_VEL = 195,
    AXIS__CONTROLLER__INPUT_TORQUE = 196,
    AXIS__CONTROLLER__POS_SETPOINT = 197,
    AXIS__CONTROLLER__VEL_SETPOINT = 198,
    AXIS__CONTROLLER__TORQUE_SETPOINT = 199,
    AXIS__CONTROLLER__TRAJECTORY_DONE = 200,
    AXIS__CONTROLLER__VEL_INTEGRATOR_TORQUE = 201,
    AXIS__CONTROLLER__ANTICOGGING_VALID = 202,
    AXIS__CONTROLLER__CONFIG__GAIN_SCHEDULING_WIDTH = 203,
    AXIS__CONTROLLER__CONFIG__ENABLE_VEL_LIMIT = 204,
    AXIS__CONTROLLER__CONFIG__ENABLE_CURRENT_MODE_VEL_LIMIT = 205,
    AXIS__CONTROLLER__CONFIG__ENABLE_GAIN_SCHEDULING = 206,
    AXIS__CONTROLLER__CONFIG__ENABLE_OVERSPEED_ERROR = 207,
    AXIS__CONTROLLER__CONFIG__CONTROL_MODE = 208,
    AXIS__CONTROLLER__CONFIG__INPUT_MODE = 209,
    AXIS__CONTROLLER__CONFIG__POS_GAIN = 210,
    AXIS__CONTROLLER__CONFIG__VEL_GAIN = 211,
    AXIS__CONTROLLER__CONFIG__VEL_INTEGRATOR_GAIN = 212,
    AXIS__CONTROLLER__CONFIG__VEL_LIMIT = 213,
    AXIS__CONTROLLER__CONFIG__VEL_LIMIT_TOLERANCE = 214,
    AXIS__CONTROLLER__CONFIG__VEL_RAMP_RATE = 215,
    AXIS__CONTROLLER__CONFIG__TORQUE_RAMP_RATE = 216,
    AXIS__CONTROLLER__CONFIG__CIRCULAR_SETPOINTS = 217,
    AXIS__CONTROLLER__CONFIG__CIRCULAR_SETPOINT_RANGE = 218,
    AXIS__CONTROLLER__CONFIG__HOMING_SPEED = 219,
    AXIS__CONTROLLER__CONFIG__INERTIA = 220,
    AXIS__CONTROLLER__CONFIG__AXIS_TO_MIRROR = 221,
    AXIS__CONTROLLER__CONFIG__MIRROR_RATIO = 222,
    AXIS__CONTROLLER__CONFIG__LOAD_ENCODER_AXIS = 223,
    AXIS__CONTROLLER__CONFIG__INPUT_FILTER_BANDWIDTH = 224,
    AXIS__CONTROLLER__CONFIG__ANTICOGGING__INDEX = 225,
    AXIS__CONTROLLER__CONFIG__ANTICOGGING__PRE_CALIBRATED = 226,
    AXIS__CONTROLLER__CONFIG__ANTICOGGING__CALIB_ANTICOGGING = 227,
    AXIS__CONTROLLER__CONFIG__ANTICOGGING__CALIB_POS_THRESHOLD = 228,
    AXIS__CONTROLLER__CONFIG__ANTICOGGING__CALIB_VEL_THRESHOLD = 229,
    AXIS__CONTROLLER__CONFIG__ANTICOGGING__COGGING_RATIO = 230,
    AXIS__CONTROLLER__CONFIG__ANTICOGGING__ANTICOGGING_ENABLED = 231,
    AXIS__CONTROLLER__START_ANTICOGGING_CALIBRATION = 235,
    AXIS__ENCODER__ERROR = 236,
    AXIS__ENCODER__IS_READY = 237,
    AXIS__ENCODER__INDEX_FOUND = 238,
    AXIS__ENCODER__SHADOW_COUNT = 239,
    AXIS__ENCODER__COUNT_IN_CPR = 240,
    AXIS__ENCODER__INTERPOLATION = 241,
    AXIS__ENCODER__PHASE = 242,
    AXIS__ENCODER__POS_ESTIMATE = 243,
    AXIS__ENCODER__POS_ESTIMATE_COUNTS = 244,
    AXIS__ENCODER__POS_CPR = 245,
    AXIS__ENCODER__POS_CPR_COUNTS = 246,
    AXIS__ENCODER__POS_CIRCULAR = 247,
    AXIS__ENCODER__HALL_STATE = 248,
    AXIS__ENCODER__VEL_ESTIMATE = 249,
    AXIS__ENCODER__VEL_ESTIMATE_COUNTS = 250,
    AXIS__ENCODER__CALIB_SCAN_RESPONSE = 251,
    AXIS__ENCODER__POS_ABS = 252,
    AXIS__ENCODER__SPI_ERROR_RATE = 253,
    AXIS__ENCODER__CONFIG__MODE = 254,
    AXIS__ENCODER__CONFIG__USE_INDEX = 255,
    AXIS__ENCODER__CONFIG__FIND_IDX_ON_LOCKIN_ONLY = 256,
    AXIS__ENCODER__CONFIG__ABS_SPI_CS_GPIO_PIN = 257,
    AXIS__ENCODER__CONFIG__ZERO_COUNT_ON_FIND_IDX = 258,
    AXIS__ENCODER__CONFIG__CPR = 259,
    AXIS__ENCODER__CONFIG__OFFSET = 260,
    AXIS__ENCODER__CONFIG__PRE_CALIBRATED = 261,
    AXIS__ENCODER__CONFIG__OFFSET_FLOAT = 262,
    AXIS__ENCODER__CONFIG__ENABLE_PHASE_INTERPOLATION = 263,
    AXIS__ENCODER__CONFIG__BANDWIDTH = 264,
    AXIS__ENCODER__CONFIG__CALIB_RANGE = 265,
    AXIS__ENCODER__CONFIG__CALIB_SCAN_DISTANCE = 266,
    AXIS__ENCODER__CONFIG__CALIB_SCAN_OMEGA = 267,
    AXIS__ENCODER__CONFIG__IDX_SEARCH_UNIDIRECTIONAL = 268,
    AXIS__ENCODER__CONFIG__IGNORE_ILLEGAL_HALL_STATE = 269,
    AXIS__ENCODER__CONFIG__SINCOS_GPIO_PIN_SIN = 270,
    AXIS__ENCODER__CONFIG__SINCOS_GPIO_PIN_COS = 271,
    AXIS__SENSORLESS_ESTIMATOR__ERROR = 274,
    AXIS__SENSORLESS_ESTIMATOR__PHASE = 275,
    AXIS__SENSORLESS_ESTIMATOR__PLL_POS = 276,
    AXIS__SENSORLESS_ESTIMATOR__VEL_ESTIMATE = 277,
    AXIS__SENSORLESS_ESTIMATOR__CONFIG__OBSERVER_GAIN = 278,
    AXIS__SENSORLESS_ESTIMATOR__CONFIG__PLL_BANDWIDTH = 279,
    AXIS__SENSORLESS_ESTIMATOR__CONFIG__PM_FLUX_LINKAGE = 280,
    AXIS__TRAP_TRAJ__CONFIG__VEL_LIMIT = 281,
    AXIS__TRAP_TRAJ__CONFIG__ACCEL_LIMIT = 282,
    AXIS__TRAP_TRAJ__CONFIG__DECEL_LIMIT = 283,
    AXIS__MIN_ENDSTOP__ENDSTOP_STATE = 284,
    AXIS__MIN_ENDSTOP__CONFIG__GPIO_NUM = 285,
    AXIS__MIN_ENDSTOP__CONFIG__ENABLED = 286,
    AXIS__MIN_ENDSTOP__CONFIG__OFFSET = 287,
    AXIS__MIN_ENDSTOP__CONFIG__IS_ACTIVE_HIGH = 288,
    AXIS__MIN_ENDSTOP__CONFIG__PULLUP = 289,
    AXIS__MIN_ENDSTOP__CONFIG__DEBOUNCE_MS = 290,
    AXIS__MAX_ENDSTOP__ENDSTOP_STATE = 291,
    AXIS__MAX_ENDSTOP__CONFIG__GPIO_NUM = 292,
    AXIS__MAX_ENDSTOP__CONFIG__ENABLED = 293,
    AXIS__MAX_ENDSTOP__CONFIG__OFFSET = 294,
    AXIS__MAX_ENDSTOP__CONFIG__IS_ACTIVE_HIGH = 295,
    AXIS__MAX_ENDSTOP__CONFIG__PULLUP = 296,
    AXIS__MAX_ENDSTOP__CONFIG__DEBOUNCE_MS = 297,
    AXIS__WATCHDOG_FEED = 298,
    AXIS__CLEAR_ERRORS = 299,
};

template<int I>
struct endpoint_type;

template<> struct endpoint_type<VBUS_VOLTAGE> { typedef float type; };
template<> struct endpoint_type<IBUS> { typedef float type; };
template<> struct endpoint_type<IBUS_REPORT_FILTER_K> { typedef float type; };
template<> struct endpoint_type<SERIAL_NUMBER> { typedef uint64_t type; };
template<> struct endpoint_type<HW_VERSION_MAJOR> { typedef uint8_t type; };
template<> struct endpoint_type<HW_VERSION_MINOR> { typedef uint8_t type; };
template<> struct endpoint_type<HW_VERSION_VARIANT> { typedef uint8_t type; };
template<> struct endpoint_type<FW_VERSION_MAJOR> { typedef uint8_t type; };
template<> struct endpoint_type<FW_VERSION_MINOR> { typedef uint8_t type; };
template<> struct endpoint_type<FW_VERSION_REVISION> { typedef uint8_t type; };
template<> struct endpoint_type<FW_VERSION_UNRELEASED> { typedef uint8_t type; };
template<> struct endpoint_type<BRAKE_RESISTOR_ARMED> { typedef bool type; };
template<> struct endpoint_type<BRAKE_RESISTOR_SATURATED> { typedef bool type; };
template<> struct endpoint_type<SYSTEM_STATS__UPTIME> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__MIN_HEAP_SPACE> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__MIN_STACK_SPACE_AXIS0> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__MIN_STACK_SPACE_AXIS1> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__MIN_STACK_SPACE_COMMS> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__MIN_STACK_SPACE_USB> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__MIN_STACK_SPACE_UART> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__MIN_STACK_SPACE_CAN> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__MIN_STACK_SPACE_USB_IRQ> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__MIN_STACK_SPACE_STARTUP> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__STACK_USAGE_AXIS0> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__STACK_USAGE_AXIS1> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__STACK_USAGE_COMMS> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__STACK_USAGE_USB> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__STACK_USAGE_UART> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__STACK_USAGE_USB_IRQ> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__STACK_USAGE_STARTUP> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__STACK_USAGE_CAN> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__USB__RX_CNT> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__USB__TX_CNT> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__USB__TX_OVERRUN_CNT> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__I2C__ADDR> { typedef uint8_t type; };
template<> struct endpoint_type<SYSTEM_STATS__I2C__ADDR_MATCH_CNT> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__I2C__RX_CNT> { typedef uint32_t type; };
template<> struct endpoint_type<SYSTEM_STATS__I2C__ERROR_CNT> { typedef uint32_t type; };
template<> struct endpoint_type<CONFIG__ENABLE_UART> { typedef bool type; };
template<> struct endpoint_type<CONFIG__UART_BAUDRATE> { typedef uint32_t type; };
template<> struct endpoint_type<CONFIG__ENABLE_I2C_INSTEAD_OF_CAN> { typedef bool type; };
template<> struct endpoint_type<CONFIG__ENABLE_ASCII_PROTOCOL_ON_USB> { typedef bool type; };
template<> struct endpoint_type<CONFIG__MAX_REGEN_CURRENT> { typedef float type; };
template<> struct endpoint_type<CONFIG__BRAKE_RESISTANCE> { typedef float type; };
template<> struct endpoint_type<CONFIG__DC_BUS_UNDERVOLTAGE_TRIP_LEVEL> { typedef float type; };
template<> struct endpoint_type<CONFIG__DC_BUS_OVERVOLTAGE_TRIP_LEVEL> { typedef float type; };
template<> struct endpoint_type<CONFIG__ENABLE_DC_BUS_OVERVOLTAGE_RAMP> { typedef bool type; };
template<> struct endpoint_type<CONFIG__DC_BUS_OVERVOLTAGE_RAMP_START> { typedef float type; };
template<> struct endpoint_type<CONFIG__DC_BUS_OVERVOLTAGE_RAMP_END> { typedef float type; };
template<> struct endpoint_type<CONFIG__DC_MAX_POSITIVE_CURRENT> { typedef float type; };
template<> struct endpoint_type<CONFIG__DC_MAX_NEGATIVE_CURRENT> { typedef float type; };
template<> struct endpoint_type<CONFIG__GPIO1_PWM_MAPPING__MIN> { typedef float type; };
template<> struct endpoint_type<CONFIG__GPIO1_PWM_MAPPING__MAX> { typedef float type; };
template<> struct endpoint_type<CONFIG__GPIO2_PWM_MAPPING__MIN> { typedef float type; };
template<> struct endpoint_type<CONFIG__GPIO2_PWM_MAPPING__MAX> { typedef float type; };
template<> struct endpoint_type<CONFIG__GPIO3_PWM_MAPPING__MIN> { typedef float type; };
template<> struct endpoint_type<CONFIG__GPIO3_PWM_MAPPING__MAX> { typedef float type; };
template<> struct endpoint_type<CONFIG__GPIO4_PWM_MAPPING__MIN> { typedef float type; };
template<> struct endpoint_type<CONFIG__GPIO4_PWM_MAPPING__MAX> { typedef float type; };
template<> struct endpoint_type<CONFIG__GPIO3_ANALOG_MAPPING__MIN> { typedef float type; };
template<> struct endpoint_type<CONFIG__GPIO3_ANALOG_MAPPING__MAX> { typedef float type; };
template<> struct endpoint_type<CONFIG__GPIO4_ANALOG_MAPPING__MIN> { typedef float type; };
template<> struct endpoint_type<CONFIG__GPIO4_ANALOG_MAPPING__MAX> { typedef float type; };
template<> struct endpoint_type<USER_CONFIG_LOADED> { typedef bool type; };
template<> struct endpoint_type<CAN__ERROR> { typedef int32_t type; };
template<> struct endpoint_type<CAN__CONFIG__BAUD_RATE> { typedef uint32_t type; };
template<> struct endpoint_type<CAN__CONFIG__PROTOCOL> { typedef int32_t type; };
template<> struct endpoint_type<TEST_PROPERTY> { typedef uint32_t type; };
template<> struct endpoint_type<SAVE_CONFIGURATION> { typedef void type; };
template<> struct endpoint_type<ERASE_CONFIGURATION> { typedef void type; };
template<> struct endpoint_type<REBOOT> { typedef void type; };
template<> struct endpoint_type<ENTER_DFU_MODE> { typedef void type; };


// Per-axis endpoints
template<> struct endpoint_type<AXIS__ERROR> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__STEP_DIR_ACTIVE> { typedef bool type; };
template<> struct endpoint_type<AXIS__CURRENT_STATE> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__REQUESTED_STATE> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__LOOP_COUNTER> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__LOCKIN_STATE> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__IS_HOMED> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__STARTUP_MOTOR_CALIBRATION> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__STARTUP_ENCODER_INDEX_SEARCH> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__STARTUP_ENCODER_OFFSET_CALIBRATION> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__STARTUP_CLOSED_LOOP_CONTROL> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__STARTUP_SENSORLESS_CONTROL> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__STARTUP_HOMING> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__ENABLE_STEP_DIR> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__STEP_DIR_ALWAYS_ON> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__TURNS_PER_STEP> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__WATCHDOG_TIMEOUT> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__ENABLE_WATCHDOG> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__STEP_GPIO_PIN> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__CONFIG__DIR_GPIO_PIN> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__CONFIG__CALIBRATION_LOCKIN__CURRENT> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__CALIBRATION_LOCKIN__RAMP_TIME> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__CALIBRATION_LOCKIN__RAMP_DISTANCE> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__CALIBRATION_LOCKIN__ACCEL> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__CALIBRATION_LOCKIN__VEL> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__SENSORLESS_RAMP__CURRENT> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__SENSORLESS_RAMP__RAMP_TIME> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__SENSORLESS_RAMP__RAMP_DISTANCE> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__SENSORLESS_RAMP__ACCEL> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__SENSORLESS_RAMP__VEL> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__SENSORLESS_RAMP__FINISH_DISTANCE> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__SENSORLESS_RAMP__FINISH_ON_VEL> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__SENSORLESS_RAMP__FINISH_ON_DISTANCE> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__SENSORLESS_RAMP__FINISH_ON_ENC_IDX> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__GENERAL_LOCKIN__CURRENT> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__GENERAL_LOCKIN__RAMP_TIME> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__GENERAL_LOCKIN__RAMP_DISTANCE> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__GENERAL_LOCKIN__ACCEL> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__GENERAL_LOCKIN__VEL> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__GENERAL_LOCKIN__FINISH_DISTANCE> { typedef float type; };
template<> struct endpoint_type<AXIS__CONFIG__GENERAL_LOCKIN__FINISH_ON_VEL> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__GENERAL_LOCKIN__FINISH_ON_DISTANCE> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__GENERAL_LOCKIN__FINISH_ON_ENC_IDX> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__CAN_NODE_ID> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__CONFIG__CAN_NODE_ID_EXTENDED> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONFIG__CAN_HEARTBEAT_RATE_MS> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__FET_THERMISTOR__ERROR> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__FET_THERMISTOR__TEMPERATURE> { typedef float type; };
template<> struct endpoint_type<AXIS__FET_THERMISTOR__CONFIG__TEMP_LIMIT_LOWER> { typedef float type; };
template<> struct endpoint_type<AXIS__FET_THERMISTOR__CONFIG__TEMP_LIMIT_UPPER> { typedef float type; };
template<> struct endpoint_type<AXIS__FET_THERMISTOR__CONFIG__ENABLED> { typedef bool type; };
template<> struct endpoint_type<AXIS__MOTOR_THERMISTOR__ERROR> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__MOTOR_THERMISTOR__TEMPERATURE> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR_THERMISTOR__CONFIG__GPIO_PIN> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__MOTOR_THERMISTOR__CONFIG__POLY_COEFFICIENT_0> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR_THERMISTOR__CONFIG__POLY_COEFFICIENT_1> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR_THERMISTOR__CONFIG__POLY_COEFFICIENT_2> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR_THERMISTOR__CONFIG__POLY_COEFFICIENT_3> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR_THERMISTOR__CONFIG__TEMP_LIMIT_LOWER> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR_THERMISTOR__CONFIG__TEMP_LIMIT_UPPER> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR_THERMISTOR__CONFIG__ENABLED> { typedef bool type; };
template<> struct endpoint_type<AXIS__MOTOR__ERROR> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__MOTOR__ARMED_STATE> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__MOTOR__IS_CALIBRATED> { typedef bool type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_MEAS_PHB> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_MEAS_PHC> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__DC_CALIB_PHB> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__DC_CALIB_PHC> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__PHASE_CURRENT_REV_GAIN> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__EFFECTIVE_CURRENT_LIM> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__P_GAIN> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__I_GAIN> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__V_CURRENT_CONTROL_INTEGRAL_D> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__V_CURRENT_CONTROL_INTEGRAL_Q> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__IBUS> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__FINAL_V_ALPHA> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__FINAL_V_BETA> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__ID_SETPOINT> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__IQ_SETPOINT> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__IQ_MEASURED> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__ID_MEASURED> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__I_MEASURED_REPORT_FILTER_K> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__MAX_ALLOWED_CURRENT> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__OVERCURRENT_TRIP_LEVEL> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__ACIM_ROTOR_FLUX> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__ASYNC_PHASE_VEL> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CURRENT_CONTROL__ASYNC_PHASE_OFFSET> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__GATE_DRIVER__DRV_FAULT> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__MOTOR__TIMING_LOG__GENERAL> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__MOTOR__TIMING_LOG__ADC_CB_I> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__MOTOR__TIMING_LOG__ADC_CB_DC> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__MOTOR__TIMING_LOG__MEAS_R> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__MOTOR__TIMING_LOG__MEAS_L> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__MOTOR__TIMING_LOG__ENC_CALIB> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__MOTOR__TIMING_LOG__IDX_SEARCH> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__MOTOR__TIMING_LOG__FOC_VOLTAGE> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__MOTOR__TIMING_LOG__FOC_CURRENT> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__MOTOR__TIMING_LOG__SPI_START> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__MOTOR__TIMING_LOG__SAMPLE_NOW> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__MOTOR__TIMING_LOG__SPI_END> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__PRE_CALIBRATED> { typedef bool type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__POLE_PAIRS> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__CALIBRATION_CURRENT> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__RESISTANCE_CALIB_MAX_VOLTAGE> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__PHASE_INDUCTANCE> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__PHASE_RESISTANCE> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__TORQUE_CONSTANT> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__DIRECTION> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__MOTOR_TYPE> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__CURRENT_LIM> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__CURRENT_LIM_MARGIN> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__TORQUE_LIM> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__INVERTER_TEMP_LIMIT_LOWER> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__INVERTER_TEMP_LIMIT_UPPER> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__REQUESTED_CURRENT_RANGE> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__CURRENT_CONTROL_BANDWIDTH> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__ACIM_SLIP_VELOCITY> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__ACIM_GAIN_MIN_FLUX> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__ACIM_AUTOFLUX_MIN_ID> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__ACIM_AUTOFLUX_ENABLE> { typedef bool type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__ACIM_AUTOFLUX_ATTACK_GAIN> { typedef float type; };
template<> struct endpoint_type<AXIS__MOTOR__CONFIG__ACIM_AUTOFLUX_DECAY_GAIN> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__ERROR> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__CONTROLLER__INPUT_POS> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__INPUT_VEL> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__INPUT_TORQUE> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__POS_SETPOINT> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__VEL_SETPOINT> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__TORQUE_SETPOINT> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__TRAJECTORY_DONE> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONTROLLER__VEL_INTEGRATOR_TORQUE> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__ANTICOGGING_VALID> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__GAIN_SCHEDULING_WIDTH> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__ENABLE_VEL_LIMIT> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__ENABLE_CURRENT_MODE_VEL_LIMIT> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__ENABLE_GAIN_SCHEDULING> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__ENABLE_OVERSPEED_ERROR> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__CONTROL_MODE> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__INPUT_MODE> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__POS_GAIN> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__VEL_GAIN> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__VEL_INTEGRATOR_GAIN> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__VEL_LIMIT> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__VEL_LIMIT_TOLERANCE> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__VEL_RAMP_RATE> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__TORQUE_RAMP_RATE> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__CIRCULAR_SETPOINTS> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__CIRCULAR_SETPOINT_RANGE> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__HOMING_SPEED> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__INERTIA> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__AXIS_TO_MIRROR> { typedef uint8_t type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__MIRROR_RATIO> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__LOAD_ENCODER_AXIS> { typedef uint8_t type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__INPUT_FILTER_BANDWIDTH> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__ANTICOGGING__INDEX> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__ANTICOGGING__PRE_CALIBRATED> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__ANTICOGGING__CALIB_ANTICOGGING> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__ANTICOGGING__CALIB_POS_THRESHOLD> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__ANTICOGGING__CALIB_VEL_THRESHOLD> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__ANTICOGGING__COGGING_RATIO> { typedef float type; };
template<> struct endpoint_type<AXIS__CONTROLLER__CONFIG__ANTICOGGING__ANTICOGGING_ENABLED> { typedef bool type; };
template<> struct endpoint_type<AXIS__CONTROLLER__START_ANTICOGGING_CALIBRATION> { typedef void type; };
template<> struct endpoint_type<AXIS__ENCODER__ERROR> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__ENCODER__IS_READY> { typedef bool type; };
template<> struct endpoint_type<AXIS__ENCODER__INDEX_FOUND> { typedef bool type; };
template<> struct endpoint_type<AXIS__ENCODER__SHADOW_COUNT> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__ENCODER__COUNT_IN_CPR> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__ENCODER__INTERPOLATION> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__PHASE> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__POS_ESTIMATE> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__POS_ESTIMATE_COUNTS> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__POS_CPR> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__POS_CPR_COUNTS> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__POS_CIRCULAR> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__HALL_STATE> { typedef uint8_t type; };
template<> struct endpoint_type<AXIS__ENCODER__VEL_ESTIMATE> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__VEL_ESTIMATE_COUNTS> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__CALIB_SCAN_RESPONSE> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__POS_ABS> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__ENCODER__SPI_ERROR_RATE> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__MODE> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__USE_INDEX> { typedef bool type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__FIND_IDX_ON_LOCKIN_ONLY> { typedef bool type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__ABS_SPI_CS_GPIO_PIN> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__ZERO_COUNT_ON_FIND_IDX> { typedef bool type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__CPR> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__OFFSET> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__PRE_CALIBRATED> { typedef bool type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__OFFSET_FLOAT> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__ENABLE_PHASE_INTERPOLATION> { typedef bool type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__BANDWIDTH> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__CALIB_RANGE> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__CALIB_SCAN_DISTANCE> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__CALIB_SCAN_OMEGA> { typedef float type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__IDX_SEARCH_UNIDIRECTIONAL> { typedef bool type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__IGNORE_ILLEGAL_HALL_STATE> { typedef bool type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__SINCOS_GPIO_PIN_SIN> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__ENCODER__CONFIG__SINCOS_GPIO_PIN_COS> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__SENSORLESS_ESTIMATOR__ERROR> { typedef int32_t type; };
template<> struct endpoint_type<AXIS__SENSORLESS_ESTIMATOR__PHASE> { typedef float type; };
template<> struct endpoint_type<AXIS__SENSORLESS_ESTIMATOR__PLL_POS> { typedef float type; };
template<> struct endpoint_type<AXIS__SENSORLESS_ESTIMATOR__VEL_ESTIMATE> { typedef float type; };
template<> struct endpoint_type<AXIS__SENSORLESS_ESTIMATOR__CONFIG__OBSERVER_GAIN> { typedef float type; };
template<> struct endpoint_type<AXIS__SENSORLESS_ESTIMATOR__CONFIG__PLL_BANDWIDTH> { typedef float type; };
template<> struct endpoint_type<AXIS__SENSORLESS_ESTIMATOR__CONFIG__PM_FLUX_LINKAGE> { typedef float type; };
template<> struct endpoint_type<AXIS__TRAP_TRAJ__CONFIG__VEL_LIMIT> { typedef float type; };
template<> struct endpoint_type<AXIS__TRAP_TRAJ__CONFIG__ACCEL_LIMIT> { typedef float type; };
template<> struct endpoint_type<AXIS__TRAP_TRAJ__CONFIG__DECEL_LIMIT> { typedef float type; };
template<> struct endpoint_type<AXIS__MIN_ENDSTOP__ENDSTOP_STATE> { typedef bool type; };
template<> struct endpoint_type<AXIS__MIN_ENDSTOP__CONFIG__GPIO_NUM> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__MIN_ENDSTOP__CONFIG__ENABLED> { typedef bool type; };
template<> struct endpoint_type<AXIS__MIN_ENDSTOP__CONFIG__OFFSET> { typedef float type; };
template<> struct endpoint_type<AXIS__MIN_ENDSTOP__CONFIG__IS_ACTIVE_HIGH> { typedef bool type; };
template<> struct endpoint_type<AXIS__MIN_ENDSTOP__CONFIG__PULLUP> { typedef bool type; };
template<> struct endpoint_type<AXIS__MIN_ENDSTOP__CONFIG__DEBOUNCE_MS> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__MAX_ENDSTOP__ENDSTOP_STATE> { typedef bool type; };
template<> struct endpoint_type<AXIS__MAX_ENDSTOP__CONFIG__GPIO_NUM> { typedef uint16_t type; };
template<> struct endpoint_type<AXIS__MAX_ENDSTOP__CONFIG__ENABLED> { typedef bool type; };
template<> struct endpoint_type<AXIS__MAX_ENDSTOP__CONFIG__OFFSET> { typedef float type; };
template<> struct endpoint_type<AXIS__MAX_ENDSTOP__CONFIG__IS_ACTIVE_HIGH> { typedef bool type; };
template<> struct endpoint_type<AXIS__MAX_ENDSTOP__CONFIG__PULLUP> { typedef bool type; };
template<> struct endpoint_type<AXIS__MAX_ENDSTOP__CONFIG__DEBOUNCE_MS> { typedef uint32_t type; };
template<> struct endpoint_type<AXIS__WATCHDOG_FEED> { typedef void type; };
template<> struct endpoint_type<AXIS__CLEAR_ERRORS> { typedef void type; };


template<int I>
using endpoint_type_t = typename endpoint_type<I>::type;

}

#endif // __ODRIVE_ENDPOINTS_HPP